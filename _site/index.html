<!DOCTYPE html>
<html lang="en-us">
    <head>
        <meta charset="UTF-8">
        <title>Cache Coherence Protocols Analyzer</title>
        <meta name="description" content=""/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#157878">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/assets/css/style.css?v=1862416b544c9aba547d31ea277121c707adfe99">
    </head>
    <body>
        <section class="page-header">
            <h1 class="project-name">Cache Coherence Protocols Analyzer</h1>
            <h2 class="project-tagline"></h2>
            
            <a href="http://github.com/kshitizdange/418CacheSim" class="btn">View on GitHub</a>
            
            
            <a href="http://github.com/kshitizdange/418CacheSim/zipball/gh-pages" class="btn">Download .zip</a>
            <a href="http://github.com/kshitizdange/418CacheSim/tarball/gh-pages" class="btn">Download .tar.gz</a>
            
        </section>

        <section class="main-content">
            
<h2 id="1-summary">1. SUMMARY</h2>
<blockquote>
  <p>We are going to implement a Cache Simulator for analyzing how different Snooping-Based Cache Coherence Protocols
perform under various workloads.</p>
</blockquote>

<h2 id="2-background">2. BACKGROUND</h2>
<blockquote>
  <p>We have studied about different snooping based Cache Coherence Protocols in class. Whenever a processor wants
to read or write something, it tries to use its own cache to avoid having to go to the slow memory each time.
But, when we have multiple processors, we need to synchronize the caches, so that all processors have a coherent
view of memory. For this, one approach is to use a snooping cache, where each cache monitors the memory reads and
writes done by other caches and takes some action based on those requests. MSI is one simple choice but there
are other protocols too which offer different kinds of benefits under specific workloads.</p>
</blockquote>

<h2 id="3-the-challenge">3. THE CHALLENGE</h2>
<blockquote>
  <p>It would be interesting to implement various snooping cache based protocols and measure their performance
under different kinds of workloads. We wish to be able provide memory traces to our analyzer and by simulating
the various protocols, we will be able to determine the behavior of each protocol under varying circumstances.
This will help us gain a better understanding of how each protocol might have been implemented, and also what
the strong and weak points of each are.</p>
</blockquote>

<h2 id="4-resources">4. RESOURCES</h2>
<blockquote>
  <p>We will be writing the code from scratch. And since this is an analysis project, we donâ€™t need any additional
hardware. We will be able to run it our own laptops.
We still need to figure out how to obtain/generate the memory traces. Currently, we are thinking that we might
generate our own memory traces.</p>
</blockquote>

<h2 id="5-goals-and-deliverables">5. GOALS AND DELIVERABLES</h2>
<blockquote>
  <h3 id="51-plan-to-achieve">5.1 Plan to achieve</h3>
  <p>Cache Coherence Protocols <br />
We plan to do the analysis based on comparisons between the following 4 protocols: <br />
1. MSI <br />
2. MESI <br />
3. MOSI <br />
4. MOESI <br />
 <br /> If time permits we will try to add a few more protocols to our analysis results: <br />
1. Dragon <br />
2. MESIF <br />
3. Firefly <br />
 <br /> We will try to analyse how these protocols respond to various work loads. We will first begin with a fixed
system configuration (fixed cache size, set associativity, LRU replacement policy, number of processors) to
study the effects of different protocols. And further expand it to make the system configurable for better
analysis. <br /></p>
  <h3 id="52-memory-traces">5.2 Memory Traces</h3>
  <p>As mentioned earlier, we are still unsure of the kind of memory traces we will be using to compare the
various protocols. Generating manual traces seems favorable because we will be able to control the workload
properties. For example, are the accesses primarily reads, or is it write oriented, is just one of the cores
modifying or are all of them trying to modify. Generating workloads that mimic such different properties will
lead to more interesting comparisons between the protocols  <br /></p>
  <h3 id="53-metrics">5.3 Metrics</h3>
  <p>To compare the performance of the various protocols, we can think of two metrics.
Number of memory accesses - This includes all memory writebacks, flushes and reads. Memory accesses are slow,
hence a system that requires lower number of memory requests as compared to cache should give better performance.
This of course assumes that the interconnect used for cache coherence has much lower latency as compared to
memory. <br />
Number of bus transactions - The total number of bus transactions that are needed for executing the memory
trace. The bus messages used in snooping cache coherence protocols have to be broadcasted so that every cache
controller can see them. This generates a lot of traffic on the interconnect. Depending on the the size of the
system and the available bandwidth, there is some latency associated with each bus transaction. We would prefer
a system that minimizes the number of bus transactions. <br /></p>
</blockquote>

<h2 id="6-platform-choice">6. PLATFORM CHOICE</h2>
<blockquote>
  <p>We will be using C++ as the programming language, as this project mainly involves being able to read the
memory traces from input files and dumping them into an output file. This can be easily done in C++.</p>
</blockquote>

<h2 id="7-schedule">7. SCHEDULE</h2>
<blockquote>
  <p>Apr 11 - Apr 17 - Implement a simple LRU cache for a single processor <br />
Apr 18 - Apr 24 - Add support for cache coherence protocols - MSI, MESI <br />
Apr 25 - May 01 - Add additional protocols - MOSI, MOESI, Dragon, Firefly, etc. <br />
May 02 - May 07 - Generate different types of memory workloads and Perform Analysis <br />
May 09 - May 11 - Project Presentation Preparation <br /></p>
</blockquote>



            <footer class="site-footer">
                
                <span class="site-footer-owner"><a href="http://github.com/kshitizdange/418CacheSim">418CacheSim</a> is maintained by <a href="http://github.com/kshitizdange">kshitizdange</a>.</span>
                
                <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span>
            </footer>
        </section>

        
    </body>
</html>
